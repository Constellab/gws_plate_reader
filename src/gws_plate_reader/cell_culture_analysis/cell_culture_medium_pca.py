import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import plotly.express as px
import plotly.graph_objects as go

from gws_core import (
    ConfigParams, InputSpec, InputSpecs, OutputSpec, OutputSpecs,
    Task, TaskInputs, TaskOutputs, task_decorator, ConfigSpecs,
    Table, StrParam, PlotlyResource, Tag
)


@task_decorator(
    "CellCultureMediumPCA",
    human_name="Cell Culture Medium PCA",
    short_description="Performs PCA analysis on cell culture medium composition data"
)
class CellCultureMediumPCA(Task):
    """
    [Generated by Task Expert Agent]

    Performs **Principal Component Analysis (PCA)** on cell culture medium composition data.

    This task takes a Table containing medium composition data and performs dimensionality
    reduction using PCA. It generates:
    - A table of PCA scores for all samples
    - A scatter plot showing PC1 vs PC2 projection
    - A biplot combining scores and variable loadings

    ## Input
    - **medium_table**: Table with medium composition data. Must contain a 'MILIEU' column
      identifying different medium, and numeric columns for compositional features.

    ## Configuration
    - **medium_column**: Name of the column containing medium identifiers (default: 'MILIEU')

    ## Outputs
    - **scores_table**: Table containing PCA scores (principal components) for each sample
    - **scatter_plot**: Plotly scatter plot of PC1 vs PC2 with color-coded medium groups
    - **biplot**: Plotly biplot combining sample scores and variable loadings

    ## Notes
    - Use CellCultureMediumTableFilter task before PCA to select specific medium
    - Data is standardized (mean=0, std=1) before PCA
    - The number of components is determined automatically based on data dimensions
    """

    input_specs = InputSpecs({
        'medium_table': InputSpec(
            Table,
            human_name="Medium Table",
            short_description="Table containing medium composition data with MILIEU column"
        )
    })

    output_specs = OutputSpecs({
        'scores_table': OutputSpec(
            Table,
            human_name="PCA Scores Table",
            short_description="Table containing principal component scores for each sample"
        ),
        'scatter_plot': OutputSpec(
            PlotlyResource,
            human_name="PCA Scatter Plot",
            short_description="Scatter plot showing PC1 vs PC2 projection colored by medium"
        ),
        'biplot': OutputSpec(
            PlotlyResource,
            human_name="PCA Biplot",
            short_description="Biplot combining sample scores and variable loadings"
        )
    })

    config_specs = ConfigSpecs({
        'medium_column': StrParam(
            default_value='MILIEU',
            human_name="Medium Column Name",
            short_description="Name of the column containing medium identifiers",
            visibility='public'
        )
    })

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        """Run PCA analysis on medium composition data"""

        self.log_info_message("Starting PCA analysis on medium composition data")

        # Get parameters
        medium_col = params.get_value('medium_column')

        # Get input table
        medium_table: Table = inputs['medium_table']
        df = medium_table.get_data()

        self.log_info_message(f"Successfully loaded table with {len(df)} rows and {len(df.columns)} columns")

        # Verify medium column exists
        if medium_col not in df.columns:
            raise ValueError(f"Column '{medium_col}' not found in table. Available columns: {list(df.columns)}")

        self.update_progress_value(20, "Preparing data...")

        if len(df) == 0:
            raise ValueError("Input table is empty")

        # Separate medium identifiers and numeric features
        milieu = df[medium_col].copy()
        X_num = df.drop(columns=[medium_col])

        if len(X_num) < 2:
            raise ValueError(f"Insufficient data for PCA: only {len(X_num)} samples available")

        self.update_progress_value(40, "Performing PCA...")

        # Standardize data
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X_num)

        # Perform PCA
        n_comp = min(X_scaled.shape[0], X_scaled.shape[1])
        pca = PCA(n_components=n_comp)
        scores = pca.fit_transform(X_scaled)

        expl_var = pca.explained_variance_ratio_
        pc1_var, pc2_var = expl_var[0] * 100, expl_var[1] * 100

        self.log_success_message(f"PCA completed: PC1 explains {pc1_var:.2f}%, PC2 explains {pc2_var:.2f}%")

        # Create scores dataframe
        scores_df = pd.DataFrame(scores, columns=[f"PC{i+1}" for i in range(scores.shape[1])])
        scores_df.insert(0, medium_col, milieu.values)

        self.update_progress_value(60, "Creating scatter plot...")

        # Create scatter plot
        scatter_title = f"PCA â€” PC1 vs PC2 Projection (PC1 {pc1_var:.1f}%, PC2 {pc2_var:.1f}%)"
        fig_scatter = px.scatter(
            scores_df,
            x="PC1", y="PC2",
            color=medium_col,
            title=scatter_title,
            labels={
                "PC1": f"PC1 ({pc1_var:.1f}%)",
                "PC2": f"PC2 ({pc2_var:.1f}%)",
                medium_col: "Medium"
            },
            hover_data={medium_col: True}
        )
        fig_scatter.update_layout(
            legend_title_text="Medium",
            template="plotly_white",
            height=600,
            width=800
        )

        self.update_progress_value(80, "Creating biplot...")

        # Create biplot
        # Calculate loadings (variable contributions)
        loadings = pca.components_.T[:, :2] * np.sqrt(pca.explained_variance_[:2])

        # Scale scores to [-1, 1] range for visualization
        scores_2d = scores[:, :2]
        scores_2d_scaled = scores_2d / np.maximum(1e-12, np.abs(scores_2d).max(axis=0))

        # Normalize loadings
        max_abs_loading = np.abs(loadings).max()
        loadings_scaled = loadings / (max_abs_loading if max_abs_loading > 0 else 1.0)

        # Create biplot figure
        fig_biplot = go.Figure()
        fig_biplot.update_layout(
            title=f"PCA Biplot (PC1 {pc1_var:.1f}%, PC2 {pc2_var:.1f}%)",
            xaxis_title=f"PC1 ({pc1_var:.1f}%)",
            yaxis_title=f"PC2 ({pc2_var:.1f}%)",
            template="plotly_white",
            height=700,
            width=900
        )

        # Add sample points grouped by medium
        for grp, gdf in scores_df.assign(
            PC1s=scores_2d_scaled[:, 0],
            PC2s=scores_2d_scaled[:, 1]
        ).groupby(medium_col):
            fig_biplot.add_trace(go.Scatter(
                x=gdf["PC1s"], y=gdf["PC2s"],
                mode="markers",
                name=str(grp),
                hovertext=gdf[medium_col],
                hovertemplate=f"{medium_col}: %{{hovertext}}<br>PC1: %{{x:.3f}}<br>PC2: %{{y:.3f}}<extra></extra>"
            ))

        # Add variable loading arrows as traces (so they appear in legend)
        for i, var in enumerate(X_num.columns):
            x, y = loadings_scaled[i, 0], loadings_scaled[i, 1]

            # Add arrow as a scatter trace with annotations
            # This makes it controllable via legend
            fig_biplot.add_trace(go.Scatter(
                x=[0, x],
                y=[0, y],
                mode="lines+text",
                line=dict(color="gray", width=2),
                text=["", var],  # Empty text at origin, variable name at tip
                textposition="top center",
                textfont=dict(size=10, color="black"),
                name=var,
                hovertemplate=f"{var}<br>PC1: {x:.3f}<br>PC2: {y:.3f}<extra></extra>",
                showlegend=True
            ))

            # Add arrowhead using annotation (these won't show in legend but will follow trace visibility)
            fig_biplot.add_annotation(
                x=x, y=y,
                ax=0, ay=0,
                xref="x", yref="y",
                axref="x", ayref="y",
                showarrow=True,
                arrowhead=2,
                arrowsize=1,
                arrowwidth=2,
                arrowcolor="gray",
                visible=True
            )

        # Make plot square and add margins
        fig_biplot.update_yaxes(scaleanchor="x", scaleratio=1)
        fig_biplot.update_layout(
            margin=dict(l=40, r=40, t=60, b=40),
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02,
                tracegroupgap=10
            )
        )

        self.update_progress_value(95, "Preparing outputs...")

        # Create output resources
        scores_table = Table(scores_df)

        # Set name and add tags to identify this as an analysis output
        scores_table.name = "PCA scores table"
        scores_table.tags.add_tag(Tag("analysis_type", "pca"))
        scores_table.tags.add_tag(Tag("analysis_task", "CellCultureMediumPCA"))
        scores_table.tags.add_tag(Tag("output_type", "scores"))

        scatter_resource = PlotlyResource()
        scatter_resource.figure = fig_scatter

        # Set name and add tags to scatter plot
        scatter_resource.name = "PCA scatter plot (PC1 vs PC2)"
        scatter_resource.tags.add_tag(Tag("analysis_type", "pca"))
        scatter_resource.tags.add_tag(Tag("analysis_task", "CellCultureMediumPCA"))
        scatter_resource.tags.add_tag(Tag("plot_type", "scatter"))
        scatter_resource.tags.add_tag(Tag("components", "PC1_PC2"))

        biplot_resource = PlotlyResource()
        biplot_resource.figure = fig_biplot

        # Set name and add tags to biplot
        biplot_resource.name = "PCA biplot (scores + loadings)"
        biplot_resource.tags.add_tag(Tag("analysis_type", "pca"))
        biplot_resource.tags.add_tag(Tag("analysis_task", "CellCultureMediumPCA"))
        biplot_resource.tags.add_tag(Tag("plot_type", "biplot"))
        biplot_resource.tags.add_tag(Tag("components", "PC1_PC2"))

        self.log_success_message("PCA analysis completed successfully")
        self.update_progress_value(100, "Done")

        return {
            'scores_table': scores_table,
            'scatter_plot': scatter_resource,
            'biplot': biplot_resource
        }
