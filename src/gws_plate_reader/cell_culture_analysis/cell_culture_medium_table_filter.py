from gws_core import (ConfigParams, InputSpec, InputSpecs, OutputSpec,
                      OutputSpecs, Task, TaskInputs, TaskOutputs,
                      task_decorator, ConfigSpecs, Table, ListParam, StrParam)


@task_decorator("CellCultureMediumTableFilter", human_name="Cell Culture Medium Table Filter",
                short_description="Filters medium table by selecting specific medium names")
class CellCultureMediumTableFilter(Task):
    """
    [Generated by Task Expert Agent]

    Filters a medium composition table to keep only selected medium.

    This task takes a Table containing medium composition data and filters it to retain
    only the rows corresponding to the selected medium names. The first column is assumed
    to contain the medium identifiers.

    ## Input
    - **medium_table**: Table with medium composition data. The first column should contain
      medium names/identifiers, and other columns contain compositional features.

    ## Configuration
    - **medium_column**: Name of the column containing medium identifiers (default: 'MILIEU')
    - **selected_medium**: List of specific medium names to keep. If empty, all medium are kept.

    ## Output
    - **filtered_table**: Table containing only the selected medium rows

    ## Notes
    - If a selected medium is not found in the table, it will be silently skipped
    - The output table preserves the same structure as the input table
    - Empty selection list returns all medium
    """

    input_specs = InputSpecs({
        'medium_table': InputSpec(
            Table,
            human_name="Medium Table",
            short_description="Table containing medium composition data"
        )
    })

    output_specs = OutputSpecs({
        'filtered_table': OutputSpec(
            Table,
            human_name="Filtered Medium Table",
            short_description="Table with only selected medium"
        )
    })

    config_specs = ConfigSpecs({
        'medium_column': StrParam(
            default_value='MILIEU',
            human_name="Medium Column Name",
            short_description="Name of the column containing medium identifiers",
            visibility='public'
        ),
        'selected_medium': ListParam(
            default_value=[],
            human_name="Selected Medium",
            short_description="List of specific medium to keep (empty = all medium)",
            visibility='public',
            optional=True
        )
    })

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        """Filter medium table by selected medium names"""

        self.log_info_message("Starting medium table filtering")

        # Get input table
        medium_table: Table = inputs['medium_table']
        df = medium_table.get_data()

        self.log_info_message(f"Input table has {len(df)} rows and {len(df.columns)} columns")

        # Get parameters
        medium_col = params.get_value('medium_column')
        selected_medium = params.get_value('selected_medium', [])

        # Verify medium column exists
        if medium_col not in df.columns:
            raise ValueError(f"Column '{medium_col}' not found in table. Available columns: {list(df.columns)}")

        # Filter if selection is provided
        if selected_medium and len(selected_medium) > 0:
            # Filter to keep only selected medium
            filtered_df = df[df[medium_col].isin(selected_medium)].copy()

            # Log which medium were found/not found
            found_medium = set(filtered_df[medium_col].unique())
            requested_medium = set(selected_medium)
            missing_medium = requested_medium - found_medium

            if missing_medium:
                self.log_warning_message(f"Medium not found in table: {', '.join(missing_medium)}")

            self.log_info_message(f"Filtered to {len(filtered_df)} rows matching {len(found_medium)} selected medium")
        else:
            # No filter, keep all
            filtered_df = df.copy()
            self.log_info_message("No medium selection provided, keeping all rows")

        if len(filtered_df) == 0:
            self.log_warning_message("No rows remaining after filtering")

        # Create output table
        filtered_table = Table(filtered_df)
        filtered_table.name = f"{medium_table.name} (filtered)" if hasattr(
            medium_table, 'name') else "Filtered Medium Table"

        self.log_success_message("Medium table filtering completed successfully")

        return {'filtered_table': filtered_table}
