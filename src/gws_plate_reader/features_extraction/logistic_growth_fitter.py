import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from sklearn.model_selection import KFold
from scipy.interpolate import UnivariateSpline
from sklearn.metrics import r2_score
import plotly.graph_objs as go
import plotly.express as px

from gws_core import (ConfigParams, InputSpec, InputSpecs, OutputSpec,
                      OutputSpecs, Task, TaskInputs, TaskOutputs,
                      task_decorator, ConfigSpecs, IntParam, FloatParam,
                      Table, PlotlyResource)


@task_decorator("LogisticGrowthFitter", human_name="Logistic Growth Fitter",
                short_description="Fit logistic growth curves to time-series data with cross-validation")
class LogisticGrowthFitter(Task):
    """
    [Generated by Task Expert Agent]

    Fits **logistic growth curves** to time-series absorbance data using cross-validation
    to determine optimal parameters for each well.

    ## Model
    The logistic growth model is:
    ```
    A(t) = A₀ + (Amax - A₀) / (1 + exp(-μ * (t - tlag)))
    ```

    Where:
    - **A₀**: Initial absorbance
    - **Amax**: Maximum absorbance
    - **μ**: Growth rate
    - **tlag**: Lag time

    ## Process
    1. Pre-processes data with spline smoothing
    2. Performs K-Fold cross-validation to find optimal parameters
    3. Extracts growth parameters for each well
    4. Generates fitted curves and diagnostic plots

    ## Inputs
    - **table**: Time-series data with time in first column, wells in subsequent columns

    ## Outputs
    - **parameters**: Table with fitted parameters (Max_Absorbance, Growth_Rate, Lag_Time, Initial_Absorbance, Avg_R2)
    - **fitted_curves_plot**: Interactive plot showing raw data points and fitted curves with R² values
    - **growth_rate_histogram**: Histogram of growth rates distribution across wells

    ## Configuration
    - **n_splits**: Number of K-Fold cross-validation splits (default: 3)
    - **spline_smoothing**: Smoothing parameter for spline preprocessing (default: 0.045)
    """

    input_specs = InputSpecs({
        'table': InputSpec(
            Table,
            human_name="Time-series data",
            short_description="Table with time in first column and well absorbance data in subsequent columns"
        )
    })

    output_specs = OutputSpecs({
        'parameters': OutputSpec(
            Table,
            human_name="Growth parameters",
            short_description="Table containing fitted logistic growth parameters for each well"
        ),
        'fitted_curves_plot': OutputSpec(
            PlotlyResource,
            human_name="Fitted curves plot",
            short_description="Interactive plot showing raw data and fitted logistic curves with R² values"
        ),
        'growth_rate_histogram': OutputSpec(
            PlotlyResource,
            human_name="Growth rate histogram",
            short_description="Histogram showing distribution of growth rates across wells"
        )
    })

    config_specs = ConfigSpecs({
        'n_splits': IntParam(
            default_value=3,
            min_value=2,
            max_value=10,
            human_name="CV splits",
            short_description="Number of K-Fold cross-validation splits"
        ),
        'spline_smoothing': FloatParam(
            default_value=0.045,
            min_value=0.001,
            max_value=1.0,
            human_name="Spline smoothing",
            short_description="Smoothing parameter for spline preprocessing (lower = less smoothing)"
        )
    })

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        """Run logistic growth fitting with cross-validation"""

        # Get inputs and params
        input_table: Table = inputs['table']
        n_splits = params.get_value('n_splits')
        spline_smoothing = params.get_value('spline_smoothing')

        self.log_info_message("Starting logistic growth fitting analysis...")

        # Convert to DataFrame
        df = input_table.get_data()

        # Validate data
        if df.shape[1] < 2:
            raise ValueError("Table must have at least 2 columns (time + at least one well)")

        self.update_progress_value(10, "Fitting logistic growth curves...")

        # Perform fitting
        df_params, df_fitted_curves = self._fit_logistic_growth_with_cv(
            df, n_splits, spline_smoothing
        )

        self.update_progress_value(60, "Generating fitted curves plot...")

        # Generate plots
        fitted_curves_plot = self._plot_fitted_curves_with_r2(df, df_params, df_fitted_curves)

        self.update_progress_value(80, "Generating growth rate histogram...")

        growth_rate_histogram = self._plot_growth_rate_histogram(df_params)

        self.update_progress_value(95, "Preparing outputs...")

        # Create output Table
        parameters_table = Table(df_params)

        self.log_success_message(f"Successfully fitted {len(df_params)} wells")

        return {
            'parameters': parameters_table,
            'fitted_curves_plot': fitted_curves_plot,
            'growth_rate_histogram': growth_rate_histogram
        }

    def _logistic_growth(self, time, max_absorbance, growth_rate, lag_time, initial_absorbance):
        """Logistic growth function"""
        return initial_absorbance + (max_absorbance - initial_absorbance) / (
            1 + np.exp(-growth_rate * (time - lag_time))
        )

    def _fit_logistic_growth_with_cv(self, data: pd.DataFrame, n_splits: int, spline_smoothing: float):
        """Fit logistic growth model using cross-validation for each well"""
        df_params_list = []
        df_fitted_curves_list = []

        kf = KFold(n_splits=n_splits, shuffle=True, random_state=42)
        time = data.iloc[:, 0].values

        total_wells = len(data.columns[1:])

        for idx, well in enumerate(data.columns[1:]):
            self.update_progress_value(
                10 + int(50 * (idx / total_wells)),
                f"Fitting well {idx + 1}/{total_wells}: {well}"
            )

            well_data = data[well].values

            # Remove NaN values - keep only valid time-value pairs
            valid_mask = ~np.isnan(well_data)
            if np.sum(valid_mask) < 5:  # Need at least 5 points to fit
                self.log_warning_message(
                    f"Skipping {well}: insufficient data points (only {np.sum(valid_mask)} valid points)")
                continue

            time_valid = time[valid_mask]
            well_data_valid = well_data[valid_mask]

            # Spline smoothing preprocessing
            try:
                spline_interp = UnivariateSpline(time_valid, well_data_valid, s=spline_smoothing)
                well_data_smooth = spline_interp(time_valid)
            except Exception as e:
                self.log_warning_message(f"Spline smoothing failed for {well}, using raw data: {e}")
                well_data_smooth = well_data_valid

            # Initial parameter guesses
            initial_max_abs = np.max(well_data_smooth)
            initial_growth_rate = np.max(np.diff(well_data_smooth))
            initial_absorbance = well_data_smooth[0]
            initial_guesses = [initial_max_abs, initial_growth_rate, 0, initial_absorbance]

            # Bounds for curve fitting
            upperbound_initial_absorbance = initial_absorbance * 1.1
            lowerbound_initial_absorbance = initial_absorbance * 0.90
            bounds = (
                [0, 0, 0, lowerbound_initial_absorbance],
                [np.inf, np.inf, np.inf, upperbound_initial_absorbance]
            )

            # Cross-validation
            r2_scores = []
            best_fit_params = None
            best_fit_r2 = -np.inf

            for train_index, test_index in kf.split(time_valid):
                time_train, time_test = time_valid[train_index], time_valid[test_index]
                well_data_train, well_data_test = well_data_smooth[train_index], well_data_smooth[test_index]

                try:
                    params_fit, _ = curve_fit(
                        self._logistic_growth,
                        time_train,
                        well_data_train,
                        p0=initial_guesses,
                        maxfev=5000,
                        bounds=bounds
                    )

                    max_absorbance, growth_rate, lag_time, initial_absorbance = params_fit

                    well_data_pred = self._logistic_growth(
                        time_test, max_absorbance, growth_rate, lag_time, initial_absorbance
                    )
                    r2 = r2_score(well_data_test, well_data_pred)
                    r2_scores.append(r2)

                    if np.mean(r2_scores) > best_fit_r2:
                        best_fit_params = params_fit
                        best_fit_r2 = np.mean(r2_scores)

                except Exception as e:
                    self.log_warning_message(f"Fitting failed for {well} on fold: {e}")
                    continue

            if best_fit_params is None:
                self.log_error_message(f"Could not fit {well}, skipping")
                continue

            fitted_max_absorbance, fitted_growth_rate, fitted_lag_time, fitted_initial_absorbance = best_fit_params

            params_dict = {
                'Well': [well],
                'Max_Absorbance': [fitted_max_absorbance],
                'Growth_Rate': [fitted_growth_rate],
                'Lag_Time': [fitted_lag_time],
                'Initial_Absorbance': [fitted_initial_absorbance],
                'Avg_R2': [best_fit_r2]
            }

            df_params_list.append(pd.DataFrame(params_dict))

            # Generate fitted curve using valid time range
            time_fitted = np.linspace(min(time_valid), max(time_valid), 100)
            fitted_curve = self._logistic_growth(time_fitted, *best_fit_params)

            curves_dict = {
                'Time': time_fitted,
                'Fitted_Curve': fitted_curve,
                'Well': well
            }

            df_fitted_curves_list.append(pd.DataFrame(curves_dict))

        # Check if we have any results
        if len(df_params_list) == 0:
            raise ValueError("Could not fit any wells. Please check your data for sufficient valid (non-NaN) points.")

        df_params = pd.concat(df_params_list, ignore_index=True).set_index("Well")
        df_fitted_curves = pd.concat(df_fitted_curves_list, ignore_index=True).set_index("Well")

        return df_params, df_fitted_curves

    def _plot_fitted_curves_with_r2(self, data: pd.DataFrame, df_params: pd.DataFrame,
                                    df_fitted_curves: pd.DataFrame) -> PlotlyResource:
        """Plot fitted logistic growth curves with R² values and raw data points"""
        fig = go.Figure()

        colors = px.colors.qualitative.Plotly
        wells = data.columns[1:]

        for i, well in enumerate(wells):
            if well not in df_params.index:
                continue

            color = colors[i % len(colors)]

            # Get data and filter out NaN values for plotting
            time_data = data.iloc[:, 0].values
            well_data = data[well].values
            valid_mask = ~np.isnan(well_data)

            # Raw data points (only valid ones)
            fig.add_trace(go.Scatter(
                x=time_data[valid_mask],
                y=well_data[valid_mask],
                mode='markers',
                name=f'{well} - Raw Data',
                marker=dict(color=color, symbol='circle', size=6),
                showlegend=True
            ))

            # Fitted curve
            subset = df_fitted_curves[df_fitted_curves.index == well]
            r2 = df_params.loc[well, 'Avg_R2']

            fig.add_trace(go.Scatter(
                x=subset['Time'],
                y=subset['Fitted_Curve'],
                mode='lines',
                name=f'{well} (R²={r2:.2f}) - Fitted',
                line=dict(color=color, width=2)
            ))

        fig.update_layout(
            title='Logistic Growth Fitting with Raw Data and R² for Each Well',
            xaxis_title='Time',
            yaxis_title='Absorbance',
            legend_title='Wells and Fits',
            template='plotly_white'
        )

        return PlotlyResource(fig)

    def _plot_growth_rate_histogram(self, df_params: pd.DataFrame) -> PlotlyResource:
        """Plot histogram of growth rates"""
        growth_rates = df_params['Growth_Rate'].values

        fig = go.Figure()

        bin_size = (growth_rates.max() - growth_rates.min()) / 10

        fig.add_trace(go.Histogram(
            x=growth_rates,
            name='Growth Rate Distribution',
            marker_color='rgba(50, 168, 82, 0.7)',
            hoverinfo='x+y',
            xbins=dict(
                start=growth_rates.min(),
                end=growth_rates.max(),
                size=bin_size
            )
        ))

        mean_growth = np.mean(growth_rates)
        std_growth = np.std(growth_rates)

        fig.update_layout(
            title='Distribution of Growth Rates Across Wells',
            xaxis_title='Growth Rate',
            yaxis_title='Count',
            bargap=0.1,
            template='plotly_white',
            showlegend=True,
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="center",
                x=0.5
            ),
            annotations=[
                dict(
                    x=0.95,
                    y=0.95,
                    xref="paper",
                    yref="paper",
                    text=f"Mean ± Std: {mean_growth:.4f} ± {std_growth:.4f}",
                    showarrow=False,
                    bgcolor="rgba(255, 255, 255, 0.8)",
                    bordercolor="black",
                    borderwidth=1,
                    borderpad=4,
                    font=dict(size=12)
                )
            ]
        )

        return PlotlyResource(fig)
