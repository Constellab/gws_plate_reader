import numpy as np
import pandas as pd
from scipy.interpolate import UnivariateSpline
from sklearn.model_selection import KFold
import plotly.graph_objs as go
import plotly.express as px

from gws_core import (ConfigParams, InputSpec, InputSpecs, OutputSpec,
                      OutputSpecs, Task, TaskInputs, TaskOutputs,
                      task_decorator, ConfigSpecs, IntParam, FloatParam,
                      Table, PlotlyResource)


@task_decorator("SplineGrowthRateInference", human_name="Spline Growth Rate Inference",
                short_description="Infer maximum growth rate from time-series data using spline smoothing with cross-validation")
class SplineGrowthRateInference(Task):
    """
    [Generated by Task Expert Agent]

    Infers the **maximum growth rate** from time-series absorbance data using
    **non-parametric spline smoothing** with cross-validation.

    ## Method
    Unlike parametric models (e.g., logistic curves), this approach:
    - Makes no assumptions about the growth curve shape
    - Uses univariate splines to smooth the data
    - Optimizes the smoothing parameter `s` via K-Fold cross-validation
    - Computes growth rate as the maximum of the spline's first derivative

    ## Process
    1. For each well, tests multiple smoothing parameters
    2. Performs K-Fold CV to find optimal smoothing (minimizing MSE)
    3. Fits best spline on full data
    4. Computes derivative (instantaneous growth rate)
    5. Extracts maximum growth rate and corresponding time

    ## Inputs
    - **table**: Time-series data with time in first column, wells in subsequent columns

    ## Outputs
    - **parameters**: Table with inferred parameters (Best_S, Max_Growth_Rate, Max_Growth_Time)
    - **growth_curves_plot**: Plot showing original data, smoothed curves, and derivative
    - **growth_rate_comparison**: Bar chart comparing maximum growth rates across wells

    ## Configuration
    - **n_splits**: Number of K-Fold cross-validation splits (default: 5)
    - **s_min**: Minimum smoothing parameter to test (default: 0.01)
    - **s_max**: Maximum smoothing parameter to test (default: 100.0)
    - **n_s_values**: Number of smoothing values to test (default: 500)

    ## Advantages
    - Flexible for non-standard growth patterns
    - No parametric assumptions
    - Robust to noise via optimized smoothing

    ## Notes
    This method is complementary to logistic fitting. Use when:
    - Growth curves don't follow logistic pattern
    - You need only growth rate (not full curve parameters)
    - Data has complex or multi-phase growth
    """

    input_specs = InputSpecs({
        'table': InputSpec(
            Table,
            human_name="Time-series data",
            short_description="Table with time in first column and well absorbance data in subsequent columns"
        )
    })

    output_specs = OutputSpecs({
        'parameters': OutputSpec(
            Table,
            human_name="Growth rate parameters",
            short_description="Table containing optimal smoothing parameter, max growth rate, and time for each well"
        ),
        'growth_curves_plot': OutputSpec(
            PlotlyResource,
            human_name="Growth curves plot",
            short_description="Plot showing raw data, smoothed spline, and derivative (growth rate)"
        ),
        'growth_rate_comparison': OutputSpec(
            PlotlyResource,
            human_name="Growth rate comparison",
            short_description="Bar chart comparing maximum growth rates across wells"
        )
    })

    config_specs = ConfigSpecs({
        'n_splits': IntParam(
            default_value=5,
            min_value=2,
            max_value=10,
            human_name="CV splits",
            short_description="Number of K-Fold cross-validation splits"
        ),
        's_min': FloatParam(
            default_value=0.01,
            min_value=0.001,
            max_value=10.0,
            human_name="Min smoothing",
            short_description="Minimum smoothing parameter to test (lower = less smoothing)"
        ),
        's_max': FloatParam(
            default_value=100.0,
            min_value=1.0,
            max_value=1000.0,
            human_name="Max smoothing",
            short_description="Maximum smoothing parameter to test (higher = more smoothing)"
        ),
        'n_s_values': IntParam(
            default_value=500,
            min_value=10,
            max_value=1000,
            human_name="Number of s values",
            short_description="Number of smoothing parameter values to test"
        )
    })

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        """Run spline-based growth rate inference"""

        # Get inputs and params
        input_table: Table = inputs['table']
        n_splits = params.get_value('n_splits')
        s_min = params.get_value('s_min')
        s_max = params.get_value('s_max')
        n_s_values = params.get_value('n_s_values')

        self.log_info_message("Starting spline-based growth rate inference...")

        # Convert to DataFrame
        df = input_table.get_data()

        # Validate data
        if df.shape[1] < 2:
            raise ValueError("Table must have at least 2 columns (time + at least one well)")

        # Generate smoothing parameter values to test
        s_values = np.logspace(np.log10(s_min), np.log10(s_max), n_s_values)

        self.update_progress_value(10, "Inferring growth rates with spline CV...")

        # Perform inference
        df_params, spline_data = self._infer_growth_rates(
            df, s_values, n_splits
        )

        self.update_progress_value(60, "Generating growth curves plot...")

        # Generate plots
        growth_curves_plot = self._plot_growth_curves(df, spline_data)

        self.update_progress_value(80, "Generating growth rate comparison...")

        growth_rate_comparison = self._plot_growth_rate_comparison(df_params)

        self.update_progress_value(95, "Preparing outputs...")

        # Create output Table
        parameters_table = Table(df_params)

        self.log_success_message(f"Successfully analyzed {len(df_params)} wells")

        return {
            'parameters': parameters_table,
            'growth_curves_plot': growth_curves_plot,
            'growth_rate_comparison': growth_rate_comparison
        }

    def _infer_growth_rates(self, data: pd.DataFrame, s_values: np.ndarray, n_splits: int):
        """Infer growth rates using spline with CV for each well"""
        df_params_list = []
        spline_data = {}

        time = data.iloc[:, 0].values
        total_wells = len(data.columns[1:])

        kf = KFold(n_splits=n_splits, shuffle=True, random_state=42)

        for idx, well in enumerate(data.columns[1:]):
            self.update_progress_value(
                10 + int(50 * (idx / total_wells)),
                f"Processing well {idx + 1}/{total_wells}: {well}"
            )

            absorbance = data[well].values

            # Remove NaN values - keep only valid time-value pairs
            valid_mask = ~np.isnan(absorbance)
            if np.sum(valid_mask) < 5:  # Need at least 5 points to fit
                self.log_warning_message(
                    f"Skipping {well}: insufficient data points (only {np.sum(valid_mask)} valid points)")
                continue

            time_valid = time[valid_mask]
            absorbance_valid = absorbance[valid_mask]

            best_s = None
            best_cv_score = np.inf
            best_spline = None

            # Cross-validation loop over smoothing parameters
            for s in s_values:
                cv_scores = []

                # Perform KFold cross-validation
                for train_idx, val_idx in kf.split(time_valid):
                    time_train, time_val = time_valid[train_idx], time_valid[val_idx]
                    absorbance_train, absorbance_val = absorbance_valid[train_idx], absorbance_valid[val_idx]

                    try:
                        # Fit a spline on the training data
                        spline = UnivariateSpline(time_train, absorbance_train, s=s)

                        # Predict on validation data and compute error
                        absorbance_pred = spline(time_val)
                        cv_scores.append(np.mean((absorbance_val - absorbance_pred) ** 2))  # MSE
                    except Exception as e:
                        # Skip this s value if fitting fails
                        continue

                if len(cv_scores) == 0:
                    continue

                # Calculate average validation score
                avg_cv_score = np.mean(cv_scores)

                # Update best smoothing parameter if a lower validation error is found
                if avg_cv_score < best_cv_score:
                    best_cv_score = avg_cv_score
                    best_s = s
                    try:
                        best_spline = UnivariateSpline(time_valid, absorbance_valid, s=best_s)
                    except Exception as e:
                        self.log_warning_message(f"Could not fit best spline for {well}: {e}")
                        continue

            if best_spline is None:
                self.log_error_message(f"Could not find suitable spline for {well}, skipping")
                continue

            # Calculate the derivative of the best spline (growth rate)
            derivative_spline = best_spline.derivative()

            # Infer the growth rate as the maximum of the derivative
            growth_rate_values = derivative_spline(time_valid)
            max_growth_rate = np.max(growth_rate_values)
            max_growth_time = time_valid[np.argmax(growth_rate_values)]

            # Store parameters
            params_dict = {
                'Well': [well],
                'Best_S': [best_s],
                'Max_Growth_Rate': [max_growth_rate],
                'Max_Growth_Time': [max_growth_time],
                'CV_Score': [best_cv_score]
            }

            df_params_list.append(pd.DataFrame(params_dict))

            # Store spline data for plotting
            spline_data[well] = {
                'time': time_valid,
                'absorbance': absorbance_valid,
                'smoothed': best_spline(time_valid),
                'derivative': growth_rate_values
            }

        # Check if we have any results
        if len(df_params_list) == 0:
            raise ValueError("Could not analyze any wells. Please check your data for sufficient valid (non-NaN) points.")

        df_params = pd.concat(df_params_list, ignore_index=True).set_index("Well")

        return df_params, spline_data

    def _plot_growth_curves(self, data: pd.DataFrame, spline_data: dict) -> PlotlyResource:
        """Plot original data, smoothed curves, and derivatives"""
        from plotly.subplots import make_subplots

        wells = [w for w in data.columns[1:] if w in spline_data]
        colors = px.colors.qualitative.Plotly

        # Create subplots: 1 row with 2 columns
        fig = make_subplots(
            rows=1, cols=2,
            subplot_titles=('Smoothed Growth Curves', 'Growth Rate (Derivative)'),
            horizontal_spacing=0.12
        )

        for i, well in enumerate(wells):
            color = colors[i % len(colors)]
            well_data = spline_data[well]

            # Original data points
            fig.add_trace(go.Scatter(
                x=well_data['time'],
                y=well_data['absorbance'],
                mode='markers',
                name=f'{well} - Raw',
                marker=dict(color=color, symbol='circle', size=4, opacity=0.5),
                legendgroup=well,
                showlegend=True
            ), row=1, col=1)

            # Smoothed curve
            fig.add_trace(go.Scatter(
                x=well_data['time'],
                y=well_data['smoothed'],
                mode='lines',
                name=f'{well} - Smoothed',
                line=dict(color=color, width=2),
                legendgroup=well,
                showlegend=True
            ), row=1, col=1)

            # Derivative (growth rate)
            fig.add_trace(go.Scatter(
                x=well_data['time'],
                y=well_data['derivative'],
                mode='lines',
                name=f'{well} - dA/dt',
                line=dict(color=color, width=2),
                legendgroup=well,
                showlegend=False
            ), row=1, col=2)

        fig.update_xaxes(title_text="Time", row=1, col=1)
        fig.update_xaxes(title_text="Time", row=1, col=2)
        fig.update_yaxes(title_text="Absorbance", row=1, col=1)
        fig.update_yaxes(title_text="Growth Rate (dA/dt)", row=1, col=2)

        fig.update_layout(
            title='Spline-Based Growth Analysis',
            template='plotly_white',
            height=500
        )

        return PlotlyResource(fig)

    def _plot_growth_rate_comparison(self, df_params: pd.DataFrame) -> PlotlyResource:
        """Plot bar chart comparing maximum growth rates"""
        fig = go.Figure()

        wells = df_params.index.tolist()
        growth_rates = df_params['Max_Growth_Rate'].values

        colors = px.colors.qualitative.Plotly
        bar_colors = [colors[i % len(colors)] for i in range(len(wells))]

        fig.add_trace(go.Bar(
            x=wells,
            y=growth_rates,
            marker_color=bar_colors,
            text=[f'{gr:.4f}' for gr in growth_rates],
            textposition='outside',
            name='Max Growth Rate'
        ))

        # Add mean line
        mean_growth = np.mean(growth_rates)
        fig.add_hline(
            y=mean_growth,
            line_dash="dash",
            line_color="red",
            annotation_text=f"Mean: {mean_growth:.4f}",
            annotation_position="right"
        )

        fig.update_layout(
            title='Maximum Growth Rate Comparison',
            xaxis_title='Well',
            yaxis_title='Max Growth Rate (dA/dt)',
            template='plotly_white',
            showlegend=False
        )

        return PlotlyResource(fig)
